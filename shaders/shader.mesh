#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_debug_printf : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_16bit_storage : require

#define CHUNK_SIZE 32

layout(triangles, max_vertices = 36, max_primitives = 12) out;

// Redefine the struct to explicitly not use other fields.
out gl_MeshPerVertexEXT
{
    vec4 gl_Position;
}
gl_MeshVerticesEXT[];

layout(location = 0) out vec3 colors[];

layout(binding = 0) uniform UniformBufferObject
{
    mat4 view;
    mat4 proj;
}
ubo;

layout(push_constant) uniform PushConstants
{
    i64vec3 model;
}
pcs;

layout(set = 1, binding = 0) readonly buffer BlocksBuffer
{
    uint16_t blocks[];
};

const vec3 vertices[8] = {
    vec3(0, 0, 1),
    vec3(1, 0, 1),
    vec3(0, 1, 1),
    vec3(1, 1, 1),
    vec3(0, 0, 0),
    vec3(1, 0, 0),
    vec3(0, 1, 0),
    vec3(1, 1, 0)
};

const uvec3 indices[12] = {
    uvec3(2, 6, 7),
    uvec3(2, 3, 7),
    uvec3(0, 4, 5),
    uvec3(0, 1, 5),
    uvec3(0, 2, 6),
    uvec3(0, 4, 6),
    uvec3(1, 3, 7),
    uvec3(1, 5, 7),
    uvec3(0, 2, 3),
    uvec3(0, 1, 3),
    uvec3(4, 6, 7),
    uvec3(4, 5, 7)
};

const ivec3 posOffsetPerDirection[6] = {
    ivec3(0, 1, 0),
    ivec3(0, -1, 0),
    ivec3(-1, 0, 0),
    ivec3(1, 0, 0),
    ivec3(0, 0, 1),
    ivec3(0, 0, -1),
};

vec3 getColor(int face)
{
    uint color;
    switch (face) {
    case 0: // top
        color = 10;
        break;
    case 1: // bottom
        color = 4;
        break;
    case 2: // left
    case 3: // right
        color = 8;
        break;
    case 4: // front
    case 5: // back
        color = 6;
        break;
    default:
        color = 10;
    }
    return vec3(1.0, 1.0, 1.0) * (float(color) / 10.0);
}

uint getIndex(uvec3 pos)
{
    uint i = (pos.x * CHUNK_SIZE + pos.y) * CHUNK_SIZE + pos.z;
    if (i >= CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE) {
        debugPrintfEXT("ERRRRRRRRRRRRRRRR");
    }
    return i;
}

void emitFace(vec3 blockPos, int direction, uint face_idx)
{
    vec3 color = getColor(direction);
    for (int i = 0; i < 2; i++) {
        uvec3 indice = indices[direction * 2 + i];
        uint triangle_idx = face_idx * 2 + i;
        for (int j = 0; j < 3; j++) {
            gl_MeshVerticesEXT[triangle_idx * 3 + j].gl_Position = ubo.proj * ubo.view * vec4(blockPos + vertices[indice[j]], 1.0);
            colors[triangle_idx * 3 + j] = color;
        }
        gl_PrimitiveTriangleIndicesEXT[triangle_idx] = uvec3(triangle_idx * 3, triangle_idx * 3 + 1, triangle_idx * 3 + 2);
    }
}

bool blockExist(uvec3 pos)
{
    return int(blocks[getIndex(pos)]) != 0;
}

bool blockExist_(ivec3 pos)
{
    for (int i = 0; i < 3; i++) {
        if (pos[i] < 0 || pos[i] >= CHUNK_SIZE) {
            return false;
        }
    }
    return blockExist(uvec3(pos));
}

void main()
{
    uvec3 self_pos = gl_GlobalInvocationID;

    if (!blockExist(self_pos)) {
        SetMeshOutputsEXT(0, 0);
        return;
    }

    bool neighbourBlocksExists[6] = { false, false, false, false, false, false };

    uint triangles_count = 0;
    for (int dir = 0; dir < 6; dir++) {
        ivec3 off = posOffsetPerDirection[dir];
        bool blockExist = blockExist_(ivec3(self_pos) + off);
        neighbourBlocksExists[dir] = blockExist;
        if (!blockExist) {
            triangles_count += 2;
        }
    }

    SetMeshOutputsEXT(triangles_count * 3, triangles_count);

    uint drawed_faces = 0;
    vec3 pos = vec3(pcs.model * 32) + self_pos;
    for (int i = 0; i < 6; i++) {
        if (!neighbourBlocksExists[i]) {
            emitFace(pos, i, drawed_faces);
            drawed_faces++;
        }
    }
}